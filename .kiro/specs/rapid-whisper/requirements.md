# Документ Требований: RapidWhisper

## Введение

RapidWhisper - это приложение для транскрипции речи в текст, клон SuperWhisper, использующее GLM API для распознавания речи. Приложение должно обеспечивать минималистичный, современный интерфейс в стиле macOS/Windows виджета с плавающим окном, анимированной звуковой волной и мгновенным копированием результата в буфер обмена.

## Глоссарий

- **Application**: Главное приложение RapidWhisper
- **Floating_Window**: Плавающее окно в форме "пилюли", отображаемое поверх всех окон
- **Audio_Engine**: Компонент для записи и обработки аудио с микрофона
- **Waveform_Visualizer**: Компонент для визуализации звуковой волны
- **GLM_Client**: Клиент для взаимодействия с Zhipu GLM API
- **Hotkey_Manager**: Менеджер глобальных горячих клавиш
- **Silence_Detector**: Детектор тишины для автоматической остановки записи
- **Clipboard_Manager**: Менеджер буфера обмена
- **RMS**: Root Mean Square - среднеквадратичное значение громкости аудио

## Требования

### Требование 1: Глобальная Активация Приложения

**User Story:** Как пользователь, я хочу активировать приложение глобальной горячей клавишей из любого приложения, чтобы быстро начать запись голоса без переключения окон.

#### Критерии Приемки

1. THE Hotkey_Manager SHALL регистрировать глобальную горячую клавишу F1 при запуске приложения
2. WHEN пользователь нажимает F1, THE Application SHALL показать Floating_Window поверх всех активных окон
3. WHEN Floating_Window уже отображается и пользователь нажимает F1, THE Application SHALL остановить текущую запись
4. THE Hotkey_Manager SHALL работать независимо от того, какое приложение находится в фокусе
5. IF регистрация горячей клавиши не удалась, THEN THE Application SHALL уведомить пользователя и предложить альтернативную клавишу

### Требование 2: Визуальный Дизайн Плавающего Окна

**User Story:** Как пользователь, я хочу видеть современное минималистичное окно в стиле SuperWhisper, чтобы приложение выглядело эстетично и не отвлекало от работы.

#### Критерии Приемки

1. THE Floating_Window SHALL иметь форму скругленного прямоугольника (пилюли) с радиусом скругления 30px
2. THE Floating_Window SHALL отображаться по центру экрана при активации
3. THE Floating_Window SHALL иметь эффект размытого фона (Frosted Glass/Acrylic effect)
4. THE Floating_Window SHALL быть без рамки (frameless) и системных кнопок
5. THE Floating_Window SHALL всегда оставаться поверх всех других окон
6. THE Floating_Window SHALL иметь полупрозрачный фон с цветом rgba(0, 0, 0, 150)
7. WHEN Floating_Window появляется, THE Application SHALL анимировать появление с плавным fade-in эффектом
8. WHEN Floating_Window скрывается, THE Application SHALL анимировать исчезновение с плавным fade-out эффектом

### Требование 3: Запись Аудио с Микрофона

**User Story:** Как пользователь, я хочу записывать свой голос через микрофон, чтобы преобразовать речь в текст.

#### Критерии Приемки

1. WHEN Floating_Window появляется, THE Audio_Engine SHALL немедленно начать запись с микрофона по умолчанию
2. THE Audio_Engine SHALL записывать аудио в формате WAV с частотой дискретизации 16000 Hz
3. THE Audio_Engine SHALL использовать моно канал для записи
4. THE Audio_Engine SHALL буферизировать аудио данные в памяти во время записи
5. WHEN запись останавливается, THE Audio_Engine SHALL сохранить аудио во временный файл
6. IF микрофон недоступен, THEN THE Application SHALL показать сообщение об ошибке и закрыть окно

### Требование 4: Визуализация Звуковой Волны

**User Story:** Как пользователь, я хочу видеть анимированную звуковую волну во время записи, чтобы понимать, что приложение активно записывает мой голос.

#### Критерии Приемки

1. WHILE запись активна, THE Waveform_Visualizer SHALL отображать динамическую звуковую волну в центре Floating_Window
2. THE Waveform_Visualizer SHALL обновлять визуализацию каждые 50 миллисекунд
3. THE Waveform_Visualizer SHALL вычислять RMS громкости из текущего аудио буфера
4. THE Waveform_Visualizer SHALL масштабировать высоту/амплитуду волны пропорционально RMS значению
5. THE Waveform_Visualizer SHALL создавать эффект "дыхания" волны в такт голосу пользователя
6. THE Waveform_Visualizer SHALL использовать плавную интерполяцию между значениями для избежания резких скачков
7. THE Waveform_Visualizer SHALL работать в отдельном потоке для предотвращения лагов UI

### Требование 5: Автоматическое Определение Тишины

**User Story:** Как пользователь, я хочу, чтобы запись автоматически останавливалась после паузы в речи, чтобы не нажимать клавишу повторно.

#### Критерии Приемки

1. WHILE запись активна, THE Silence_Detector SHALL непрерывно анализировать уровень громкости
2. WHEN RMS громкости остается ниже порогового значения в течение 1.5 секунд, THE Silence_Detector SHALL инициировать остановку записи
3. THE Silence_Detector SHALL использовать адаптивный порог, учитывающий фоновый шум
4. THE Silence_Detector SHALL игнорировать короткие паузы (менее 0.5 секунды) между словами
5. WHEN тишина обнаружена, THE Application SHALL немедленно перейти к этапу обработки

### Требование 6: Интеграция с GLM API

**User Story:** Как пользователь, я хочу, чтобы мой голос быстро и точно преобразовывался в текст через GLM API, чтобы получить результат за 1-2 секунды.

#### Критерии Приемки

1. THE GLM_Client SHALL использовать OpenAI Python SDK с настроенным base_url на Zhipu AI API
2. THE GLM_Client SHALL загружать API ключ из переменной окружения GLM_API_KEY
3. WHEN запись завершена, THE GLM_Client SHALL отправить аудио файл на транскрипцию
4. THE GLM_Client SHALL использовать модель whisper-1 для транскрипции
5. THE GLM_Client SHALL устанавливать таймаут запроса 30 секунд
6. WHEN транскрипция получена, THE GLM_Client SHALL извлечь текст из JSON ответа
7. IF API возвращает ошибку, THEN THE Application SHALL показать сообщение об ошибке пользователю
8. IF сетевое соединение недоступно, THEN THE Application SHALL показать сообщение о проблемах с подключением

### Требование 7: Анимация Обработки

**User Story:** Как пользователь, я хочу видеть индикатор загрузки во время отправки аудио в API, чтобы понимать, что приложение обрабатывает мой запрос.

#### Критерии Приемки

1. WHEN запись останавливается, THE Waveform_Visualizer SHALL плавно трансформироваться в спиннер загрузки
2. WHILE запрос к API выполняется, THE Application SHALL отображать анимированный индикатор прогресса
3. THE Application SHALL использовать неопределенный индикатор прогресса (indeterminate progress bar)
4. THE Application SHALL анимировать индикатор плавно без лагов
5. WHEN ответ получен, THE Application SHALL плавно скрыть индикатор загрузки

### Требование 8: Отображение и Копирование Результата

**User Story:** Как пользователь, я хочу, чтобы распознанный текст автоматически копировался в буфер обмена и отображался в окне, чтобы сразу использовать его в другом приложении.

#### Критерии Приемки

1. WHEN текст получен от GLM API, THE Application SHALL отобразить текст внутри Floating_Window
2. THE Application SHALL автоматически скопировать полный текст в буфер обмена через Clipboard_Manager
3. THE Application SHALL показать первые 100 символов текста в окне, если текст длиннее
4. THE Application SHALL анимировать появление текста с эффектом fade-in
5. THE Application SHALL показать уведомление "Текст скопирован" в течение 1 секунды
6. WHEN текст отображен, THE Application SHALL автоматически скрыть окно через 2-3 секунды
7. THE Application SHALL сохранить окно видимым до следующего нажатия горячей клавиши, если пользователь наводит курсор на окно

### Требование 9: Производительность и Многопоточность

**User Story:** Как пользователь, я хочу, чтобы приложение работало быстро и плавно без лагов, чтобы процесс транскрипции был мгновенным.

#### Критерии Приемки

1. THE Audio_Engine SHALL работать в отдельном потоке от UI потока
2. THE GLM_Client SHALL выполнять API запросы в отдельном потоке
3. THE Waveform_Visualizer SHALL обновляться с частотой минимум 20 FPS
4. THE Application SHALL обрабатывать полный цикл (конец речи -> текст в буфере) за 1-2 секунды при нормальном интернет-соединении
5. THE Application SHALL не блокировать UI во время записи или обработки
6. THE Application SHALL освобождать ресурсы микрофона немедленно после остановки записи

### Требование 10: Обработка Ошибок и Граничных Случаев

**User Story:** Как пользователь, я хочу получать понятные сообщения об ошибках, чтобы понимать, что пошло не так и как это исправить.

#### Критерии Приемки

1. IF микрофон используется другим приложением, THEN THE Application SHALL показать сообщение "Микрофон занят другим приложением"
2. IF API ключ отсутствует или неверен, THEN THE Application SHALL показать сообщение "Проверьте GLM_API_KEY в .env файле"
3. IF аудио файл пустой или слишком короткий (менее 0.5 секунды), THEN THE Application SHALL показать сообщение "Запись слишком короткая, попробуйте еще раз"
4. IF сетевое соединение прервано во время запроса, THEN THE Application SHALL показать сообщение "Ошибка сети, проверьте подключение"
5. WHEN ошибка происходит, THE Application SHALL логировать детали ошибки в файл для отладки
6. WHEN ошибка происходит, THE Application SHALL возвращаться в режим ожидания для новой записи

### Требование 11: Конфигурация и Настройки

**User Story:** Как пользователь, я хочу настраивать параметры приложения, чтобы адаптировать его под свои нужды.

#### Критерии Приемки

1. THE Application SHALL загружать конфигурацию из .env файла при запуске
2. THE Application SHALL поддерживать настройку горячей клавиши через конфигурационный файл
3. THE Application SHALL поддерживать настройку порога тишины через конфигурационный файл
4. THE Application SHALL поддерживать настройку времени автоматического скрытия окна
5. THE Application SHALL использовать значения по умолчанию, если конфигурационный файл отсутствует

### Требование 12: Управление Жизненным Циклом Приложения

**User Story:** Как пользователь, я хочу, чтобы приложение корректно запускалось и завершалось, чтобы не оставлять висящие процессы.

#### Критерии Приемки

1. WHEN приложение запускается, THE Application SHALL инициализировать все компоненты в правильном порядке
2. WHEN приложение завершается, THE Application SHALL корректно освободить все ресурсы (микрофон, потоки, временные файлы)
3. THE Application SHALL удалять временные аудио файлы после успешной транскрипции
4. THE Application SHALL отменять регистрацию глобальных горячих клавиш при завершении
5. THE Application SHALL сохранять логи работы для последующей отладки
6. WHEN пользователь закрывает приложение, THE Application SHALL завершиться корректно без зависания процессов
